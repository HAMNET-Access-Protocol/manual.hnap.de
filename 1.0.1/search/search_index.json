{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HNAP Manual MOEP This documentation contains installation and configuration manuals for HNAP4PlutoSDR. It is split into two parts. The first part will help you to get the system running and do some configuration as an end-user. The second part is dedicated to developers who want to modify and build the whole system themselves. User guide \u00b6 Start here ! Developer's guide \u00b6 There are 3 main things to build: Build the complete firmware image that can be flashed to the pluto. Build the main basestation and client applications that are run on the pluto without building the firmware. This is only useful if you already have flashed the firmware and want to develop on the client/basestation applications. Build a simulation target that does not require the Pluto Hardware. Useful to see how the PHY and MAC layer work when developing. This documentation is licensed under CC BY-SA 4.0 .","title":"Home"},{"location":"#user-guide","text":"Start here !","title":"User guide"},{"location":"#developers-guide","text":"There are 3 main things to build: Build the complete firmware image that can be flashed to the pluto. Build the main basestation and client applications that are run on the pluto without building the firmware. This is only useful if you already have flashed the firmware and want to develop on the client/basestation applications. Build a simulation target that does not require the Pluto Hardware. Useful to see how the PHY and MAC layer work when developing. This documentation is licensed under CC BY-SA 4.0 .","title":"Developer's guide"},{"location":"advanced_config/","text":"Both basestation and client may be configured via a config.txt file. We use library libconfig and its syntax for the config file. The configuration is split into currently three parts: PHY layer, Platform and log configuration. The default configuration is given in config.txt in this repo. The configuration file can be used by passing the -c <config-file> parameter to the applications. Frequency offset calibration \u00b6 The default Pluto TCXO has a bad accuracy and might need some initial calibration. The client and the client calib tool perform an initial cfo estimation and retune the transceiver to the correct carrier frequency. However, the offset estimation only works in a range of +-2Khz, the default TCXO might give larger offsets. A simple method is to recalibrate the XO in steps of 100Hz and test until the client finds sync. The TCXO can be calibrated using the fw_setenv command: fw_setenv xo_correction <new frequency> The default frequency is 40Mhz, so try 39999800 39999900 etc. Instead of tweaking the TCXO, you can also specify the frequency of the client with the -f flag. The default DL carrier is located at 439.7 MHz, try frequencies nearby if your client cannot get sync. Note In the first minutes after the Pluto started, the frequency offset varies by sometimes multiple kHz. Let the Pluto run and heat up for some minutes, if you cannot find a constant offset. The offset will settle after a while.","title":"Advanced Configuration"},{"location":"advanced_config/#frequency-offset-calibration","text":"The default Pluto TCXO has a bad accuracy and might need some initial calibration. The client and the client calib tool perform an initial cfo estimation and retune the transceiver to the correct carrier frequency. However, the offset estimation only works in a range of +-2Khz, the default TCXO might give larger offsets. A simple method is to recalibrate the XO in steps of 100Hz and test until the client finds sync. The TCXO can be calibrated using the fw_setenv command: fw_setenv xo_correction <new frequency> The default frequency is 40Mhz, so try 39999800 39999900 etc. Instead of tweaking the TCXO, you can also specify the frequency of the client with the -f flag. The default DL carrier is located at 439.7 MHz, try frequencies nearby if your client cannot get sync. Note In the first minutes after the Pluto started, the frequency offset varies by sometimes multiple kHz. Let the Pluto run and heat up for some minutes, if you cannot find a constant offset. The offset will settle after a while.","title":"Frequency offset calibration"},{"location":"build_apps/","text":"Build applications without building the firmware \u00b6 If you do not want to compile the complete firmware image, but still want to make changes to the basestation/client, use this guide for how to cross-compile the applications. 1. Get ARM toolchain \u00b6 Already got Xilinx SDK installed? If you already have the Xilinx SDK installed, you can skip this step. You may have to add the toolchain folder to your path, though. (add export PATH=$PATH:/opt/Xilinx/SDK/2018.2/gnu/aarch32/lin/gcc-arm-linux-gnueabi/bin to ~/.profile ) First, the arm toolchain has to be installed. Again, a more detailed instruction can be found here . We use linaro toolchain 7.2-2017.11, download it from here (I've used x86_64 version). Unpack it and copy it to /usr/local/bin/ tar -xf gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf.tar.xz sudo mv gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf/ /usr/local/bin/gcc-linaro-7.2.1 Next, add the toolchain location to the path variable. To make this permanent, edit ~/.profile and add the following lines: # add linaro gcc to path export PATH = $PATH :/usr/local/bin/gcc-linaro-7.2.1/bin Log off and on to apply the changes. 2. Get custom Pluto sysroot \u00b6 To successfully cross-compile, the pluto root directory has to be known. We use a custom sysroot, that can be fetched in the release section of the repository . Download it and copy the folder to your home directory and set the environment variable PLUTO_SYSROOT_DIR . It will be used by some of the following scripts. export PLUTO_SYSROOT_DIR = $HOME /pluto-0.31.sysroot 3. Compile libraries \u00b6 We have to compile libfftw on our own, because liquid-dsp requires the single precision fftw3 lib, but adalm pluto only has the double precision version installed by default. Get the tarball from http://fftw.org/download.html and unpack it. We are using FFTW 3.3.8. wget http://fftw.org/fftw-3.3.8.tar.gz tar xzfv fftw-3.3.8.tar.gz cd fftw-3.3.8 ./configure --host=arm-linux-gnueabihf --enable-float --enable-shared --prefix=\"$PLUTO_SYSROOT_DIR/usr/\" CC=\"arm-linux-gnueabihf-gcc --sysroot=$PLUTO_SYSROOT_DIR/\" make make install This will install the shared library to the sysroot directory. libfec and liquid-dsp can be configured and cross-compiled with the follwing commands git clone --recursive https://github.com/HAMNET-Access-Protocol/HNAP4PlutoSDR.git cd HNAP4PlutoSDR/libfec ./configure arm --host = arm-linux-gnueabihf --prefix = \" $PLUTO_SYSROOT_DIR /usr/\" CC = \"arm-linux-gnueabihf-gcc --sysroot= $PLUTO_SYSROOT_DIR /\" make make install cd ../liquid-dsp apt install automake autoconf ./bootstrap.sh ./configure arm --host = arm-linux-gnueabihf --prefix = \" $PLUTO_SYSROOT_DIR /usr/\" CC = \"arm-linux-gnueabihf-gcc --sysroot= $PLUTO_SYSROOT_DIR /\" sed -i '/rpl_realloc/d' config.h sed -i '/rpl_malloc/d' config.h make make install NOTE: For liquid-dsp, the configure script does not correctly detect malloc and realloc C functions, and thus make fails! We use the sed commands to fix this. 4. Compile apps \u00b6 The apps are built using cmake. The target names are basestation client and client-calib. mkdir cmake-build-release-arm cd cmake-build-release-arm cmake -DCMAKE_BUILD_TYPE = Release -DCMAKE_TOOLCHAIN_FILE = CmakeArmToolchain.cmake .. make basestation make client make client-calib 5. Upload everything to pluto \u00b6 Configure your Host PC as described in the Host PC configuration section. To upload applications, do: cd HNAP4PlutoSDR/cmake-build-release-arm/ scp basestation client client-calib plutosdr:/root/ Now, you can log in to the pluto and run the applications. They are located in /root/. Note: every time Pluto reboots, The changed application files are lost. To make the changes permanent, the firmware image has to be changed. Host PC configuration \u00b6 In order to ease development with multiple plutos connected to your PC, you can configure your ssh client. The host key of the pluto changes every time the device reboots, so for convenience add the follwing to ~/.ssh/config : Host plutosdr HostName 192.168.2.1 HostKeyAlias plutosdr StrictHostKeyChecking=no CheckHostIP no User root ChallengeResponseAuthentication no Then the device can be accessed with ssh plutosdr (password: analog).","title":"Build apps without firmware"},{"location":"build_apps/#build-applications-without-building-the-firmware","text":"If you do not want to compile the complete firmware image, but still want to make changes to the basestation/client, use this guide for how to cross-compile the applications.","title":"Build applications without building the firmware"},{"location":"build_apps/#1-get-arm-toolchain","text":"Already got Xilinx SDK installed? If you already have the Xilinx SDK installed, you can skip this step. You may have to add the toolchain folder to your path, though. (add export PATH=$PATH:/opt/Xilinx/SDK/2018.2/gnu/aarch32/lin/gcc-arm-linux-gnueabi/bin to ~/.profile ) First, the arm toolchain has to be installed. Again, a more detailed instruction can be found here . We use linaro toolchain 7.2-2017.11, download it from here (I've used x86_64 version). Unpack it and copy it to /usr/local/bin/ tar -xf gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf.tar.xz sudo mv gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf/ /usr/local/bin/gcc-linaro-7.2.1 Next, add the toolchain location to the path variable. To make this permanent, edit ~/.profile and add the following lines: # add linaro gcc to path export PATH = $PATH :/usr/local/bin/gcc-linaro-7.2.1/bin Log off and on to apply the changes.","title":"1. Get ARM toolchain"},{"location":"build_apps/#2-get-custom-pluto-sysroot","text":"To successfully cross-compile, the pluto root directory has to be known. We use a custom sysroot, that can be fetched in the release section of the repository . Download it and copy the folder to your home directory and set the environment variable PLUTO_SYSROOT_DIR . It will be used by some of the following scripts. export PLUTO_SYSROOT_DIR = $HOME /pluto-0.31.sysroot","title":"2. Get custom Pluto sysroot"},{"location":"build_apps/#3-compile-libraries","text":"We have to compile libfftw on our own, because liquid-dsp requires the single precision fftw3 lib, but adalm pluto only has the double precision version installed by default. Get the tarball from http://fftw.org/download.html and unpack it. We are using FFTW 3.3.8. wget http://fftw.org/fftw-3.3.8.tar.gz tar xzfv fftw-3.3.8.tar.gz cd fftw-3.3.8 ./configure --host=arm-linux-gnueabihf --enable-float --enable-shared --prefix=\"$PLUTO_SYSROOT_DIR/usr/\" CC=\"arm-linux-gnueabihf-gcc --sysroot=$PLUTO_SYSROOT_DIR/\" make make install This will install the shared library to the sysroot directory. libfec and liquid-dsp can be configured and cross-compiled with the follwing commands git clone --recursive https://github.com/HAMNET-Access-Protocol/HNAP4PlutoSDR.git cd HNAP4PlutoSDR/libfec ./configure arm --host = arm-linux-gnueabihf --prefix = \" $PLUTO_SYSROOT_DIR /usr/\" CC = \"arm-linux-gnueabihf-gcc --sysroot= $PLUTO_SYSROOT_DIR /\" make make install cd ../liquid-dsp apt install automake autoconf ./bootstrap.sh ./configure arm --host = arm-linux-gnueabihf --prefix = \" $PLUTO_SYSROOT_DIR /usr/\" CC = \"arm-linux-gnueabihf-gcc --sysroot= $PLUTO_SYSROOT_DIR /\" sed -i '/rpl_realloc/d' config.h sed -i '/rpl_malloc/d' config.h make make install NOTE: For liquid-dsp, the configure script does not correctly detect malloc and realloc C functions, and thus make fails! We use the sed commands to fix this.","title":"3. Compile libraries"},{"location":"build_apps/#4-compile-apps","text":"The apps are built using cmake. The target names are basestation client and client-calib. mkdir cmake-build-release-arm cd cmake-build-release-arm cmake -DCMAKE_BUILD_TYPE = Release -DCMAKE_TOOLCHAIN_FILE = CmakeArmToolchain.cmake .. make basestation make client make client-calib","title":"4. Compile apps"},{"location":"build_apps/#5-upload-everything-to-pluto","text":"Configure your Host PC as described in the Host PC configuration section. To upload applications, do: cd HNAP4PlutoSDR/cmake-build-release-arm/ scp basestation client client-calib plutosdr:/root/ Now, you can log in to the pluto and run the applications. They are located in /root/. Note: every time Pluto reboots, The changed application files are lost. To make the changes permanent, the firmware image has to be changed.","title":"5. Upload everything to pluto"},{"location":"build_apps/#host-pc-configuration","text":"In order to ease development with multiple plutos connected to your PC, you can configure your ssh client. The host key of the pluto changes every time the device reboots, so for convenience add the follwing to ~/.ssh/config : Host plutosdr HostName 192.168.2.1 HostKeyAlias plutosdr StrictHostKeyChecking=no CheckHostIP no User root ChallengeResponseAuthentication no Then the device can be accessed with ssh plutosdr (password: analog).","title":"Host PC configuration"},{"location":"build_simulation/","text":"Build the simulation application \u00b6 The PHY and MAC layer can be simulated over a channel, in order to test BER performance. Here is how to build the target on your PC. First, install libfftw and libconfig: apt install libfftw3-dev libconfig-dev Then, compile and install libfec cd libfec ./configure make install Now we have the library dependencies for liquid-dsp installed. Install liquid-dsp: More detailed installation instruction is here: https://github.com/jgaeddert/liquid-dsp cd liquid-dsp apt install automake autoconf ./bootstrap.sh ./configure make install When running ./configure make sure that the libfec and libfftw libraries are detected! Finally, the simulation target can be compiled. The transceiver project uses cmake, the build target for the simulation is called test_mac. cd HNAP4PlutoSDR mkdir cmake-build-debug cd cmake-build-debug cmake -DCMAKE_BUILD_TYPE=Debug .. # or Release, as you wish make test_mac The simulation can be configured by setting variables in runtime/test.h and runtime/test_mac.c .","title":"Build the simulation target"},{"location":"build_simulation/#build-the-simulation-application","text":"The PHY and MAC layer can be simulated over a channel, in order to test BER performance. Here is how to build the target on your PC. First, install libfftw and libconfig: apt install libfftw3-dev libconfig-dev Then, compile and install libfec cd libfec ./configure make install Now we have the library dependencies for liquid-dsp installed. Install liquid-dsp: More detailed installation instruction is here: https://github.com/jgaeddert/liquid-dsp cd liquid-dsp apt install automake autoconf ./bootstrap.sh ./configure make install When running ./configure make sure that the libfec and libfftw libraries are detected! Finally, the simulation target can be compiled. The transceiver project uses cmake, the build target for the simulation is called test_mac. cd HNAP4PlutoSDR mkdir cmake-build-debug cd cmake-build-debug cmake -DCMAKE_BUILD_TYPE=Debug .. # or Release, as you wish make test_mac The simulation can be configured by setting variables in runtime/test.h and runtime/test_mac.c .","title":"Build the simulation application"},{"location":"building_the_fw/","text":"Building the HNAP Pluto firmware \u00b6 This section will help you to create a custom firmware that includes all libraries, apps and autoconfiguration scripts for operating the HNAP transceiver. In order to guarantee a stable operation at high data-rates, the we use the linux realtime kernel patch. The following guide includes all steps to create a custom RT linux firmware with all necessary configurations for running as a client or as basestation. Prerequisites \u00b6 Xilinx Vivado SDK \u00b6 In order to be able to build the firmware, Xilinx Vivado Webpack 2018.2 has to be installed. Get it from here . Version 2018.2 is listed in the Archive section. You have to create a Xilinx account to get the SDK, but the required webpack version is free. During the software install, make sure the SDK and the Zynq 7000 software parts are installed (all other parts can be unselected). You'll still need about 29 GB free disc space for this. This guide assumes that you install Vivado and the SDK into /opt/Xilinx/ . Custom Pluto sysroot \u00b6 To be able to compile the C applications, we need the pluto sysroot structure. The most recent firmware and application require additional libraries. The pluto-sysroot folder that includes the include files for these libs can be found under releases : pluto-0.31-mod.sysroot.zip Unzip the directory to ~/pluto-0.31.sysroot , then set the environment variable PLUTO_SYSROOT_DIR . It will be used by some of the following scripts. cd ~ wget https://github.com/HAMNET-Access-Protocol/HNAP4PlutoSDR/releases/download/v1.0.0/pluto-0.31-mod.sysroot.zip unzip pluto-0.31-mod.sysroot.zip export PLUTO_SYSROOT_DIR = $HOME /pluto-0.31.sysroot Download the Pluto firmware sources \u00b6 Clone the Pluto firmware repository: git clone --recurse-submodules -j8 https://github.com/analogdevicesinc/plutosdr-fw.git Apply the realtime patch for the linux kernel \u00b6 Next, the linux realtime kernel patch will be applied. The current plutosdr-fw Version 0.31 uses Linux Kernel Version 4.19.0. The corresponding patch is patch-4.19-rt1.patch.gz from here: https://kernel.org/pub/linux/kernel/projects/rt/4.19/older/ The patch must match the linux kernel version. If you did not download plutosdr-fw v0.31, check the linux kernel version used in plutosdr-fw as follows: $ cd plutosdr-fw/ $ make -C linux ARCH=arm zynq_pluto_defconfig $ make -C linux ARCH=arm menuconfig A menuconfig window should appear with the linux kernel version in the title. Configure the linux kernel \u00b6 Unpack the patch. Then apply it: cd plutosdr-fw/linux/ patch -p1 < /path-to-patch/patch-4.19-rt1.patch Now we will configure the linux kernel. This can be done with menuconfig. First, load the kernel config for the pluto device: cd plutosdr-fw/ make -C linux ARCH=arm zynq_pluto_defconfig Then edit it with menuconfig: make -C linux ARCH=arm menuconfig You will have do make the following changes: Go to: General Setup ---> Preemption Model ---> select Fully Preemptible Kernel (RT) Go to: Device Drivers ---> Network device support ---> Universal TUN/TAP device driver support. Type 'Y' to activate If you cannot find the entries, do a search by typing '/' and go to the search result by typing the result number, e.g. '1'. Go to 'Save' and use arch/arm/configs/zynq_pluto_defconfig to overwrite the default zynq_pluto configuration. Configure the userspace apps \u00b6 Next, we will activate some useful userspace apps in buildroot. Load the pluto default configuration. make -C buildroot ARCH=arm zynq_pluto_defconfig make -C buildroot ARCH=arm menuconfig Its the easiest to search for the apps with '/', select the result (e.g. '1') and activate it with 'y'. tunctl . Required. Must be installed to configgure the tap device fftw-single . Required. Search term 'single'. We need the single precision fftw library. Make sure to select 'BR2_PACKAGE_FFTW_SINGLE' and not the legacy option. libconfig . Required. Search term 'libconfig'. A library to parse configuration files. lldpd . Required. Link Layer Discovery protocol. Used to broadcast callsigns. iperf3 . Optional but recommended. Useful for bandwidth tests. tcpdump + gdb Optional. Useful for debugging. For me, the External toolchain kernel header version was not correctly configured. If this is not correctly set, building the firmware will fail. I had to set kernel header series 4.10.x, previously it was at 4.9.x. You can do this under 'Toolchain ---> External toolchain kernel headers series'. In order to preinstall our own applications, we will create a rootfs overlay folder and tell buildroot to overlay this folder over the created filesystem. Activate this with: System configuration ---> Root filesystem overlay directories I choose /home/lukas/plutosdr-fw/rootfs-overlay/ , keep in mind the chosen directory name when creating the overlay in the next steps. Save the configuration by using the default path. Then overwrite the pluto target config with the following command: make -C buildroot savedefconfig Now we will fill the rootfs-overlay directory. The git repository containing this readme comes with a script config-firmware.sh . It should do everything on its own. Before you run it, edit it and check that the Variables PLUTOSDR_FW_ROOTOVERLAY and PLUTO_SYSROOT_DIR point to the correct paths. Also, verify that transceiver/CmakeArmToolchain.cmake uses the correct sysroot path and the correct Xilinx toolchain path. Then run: ./config-firmware.sh The script will build all dependent libraries (libfec, liquid-dsp) and the C applications. Then it fills the rootoverlay with the applications, some startup scripts and FIR filter coefficients that we use. Build firmware image \u00b6 Now everything is set up to build the firmware image: cd plutosdr-fw/ make That's it. If you get an error like Incorrect selection of kernel headers: expected 4.14.x, got 4.10.x Incorrect selection of gcc version: expected 8.x, got 7.2.1 You have to clean your current buildroot configuration and have to start from scratch with the last saved config. Go back to the buildroot userspace configuration and make sure to save the configuration at the end. In the menuconfig step check your old settings from above and: Go to: Toolchain -> External Toolchain kernel headers series 4.10.x Go to: Toolchain -> External Toolchain gcc version -> 7.x cd plutosdr-fw/ make -C buildroot ARCH=arm clean make -C buildroot ARCH=arm zynq_pluto_defconfig make -C buildroot ARCH=arm menuconfig make -C buildroot savedefconfig make After the build finished, the firmware image can be found in plutosdr-fw/build/pluto.frm . It can be installed using these instructions .","title":"Building the Firmware"},{"location":"building_the_fw/#building-the-hnap-pluto-firmware","text":"This section will help you to create a custom firmware that includes all libraries, apps and autoconfiguration scripts for operating the HNAP transceiver. In order to guarantee a stable operation at high data-rates, the we use the linux realtime kernel patch. The following guide includes all steps to create a custom RT linux firmware with all necessary configurations for running as a client or as basestation.","title":"Building the HNAP Pluto firmware"},{"location":"building_the_fw/#prerequisites","text":"","title":"Prerequisites"},{"location":"building_the_fw/#xilinx-vivado-sdk","text":"In order to be able to build the firmware, Xilinx Vivado Webpack 2018.2 has to be installed. Get it from here . Version 2018.2 is listed in the Archive section. You have to create a Xilinx account to get the SDK, but the required webpack version is free. During the software install, make sure the SDK and the Zynq 7000 software parts are installed (all other parts can be unselected). You'll still need about 29 GB free disc space for this. This guide assumes that you install Vivado and the SDK into /opt/Xilinx/ .","title":"Xilinx Vivado SDK"},{"location":"building_the_fw/#custom-pluto-sysroot","text":"To be able to compile the C applications, we need the pluto sysroot structure. The most recent firmware and application require additional libraries. The pluto-sysroot folder that includes the include files for these libs can be found under releases : pluto-0.31-mod.sysroot.zip Unzip the directory to ~/pluto-0.31.sysroot , then set the environment variable PLUTO_SYSROOT_DIR . It will be used by some of the following scripts. cd ~ wget https://github.com/HAMNET-Access-Protocol/HNAP4PlutoSDR/releases/download/v1.0.0/pluto-0.31-mod.sysroot.zip unzip pluto-0.31-mod.sysroot.zip export PLUTO_SYSROOT_DIR = $HOME /pluto-0.31.sysroot","title":"Custom Pluto sysroot"},{"location":"building_the_fw/#download-the-pluto-firmware-sources","text":"Clone the Pluto firmware repository: git clone --recurse-submodules -j8 https://github.com/analogdevicesinc/plutosdr-fw.git","title":"Download the Pluto firmware sources"},{"location":"building_the_fw/#apply-the-realtime-patch-for-the-linux-kernel","text":"Next, the linux realtime kernel patch will be applied. The current plutosdr-fw Version 0.31 uses Linux Kernel Version 4.19.0. The corresponding patch is patch-4.19-rt1.patch.gz from here: https://kernel.org/pub/linux/kernel/projects/rt/4.19/older/ The patch must match the linux kernel version. If you did not download plutosdr-fw v0.31, check the linux kernel version used in plutosdr-fw as follows: $ cd plutosdr-fw/ $ make -C linux ARCH=arm zynq_pluto_defconfig $ make -C linux ARCH=arm menuconfig A menuconfig window should appear with the linux kernel version in the title.","title":"Apply the realtime patch for the linux kernel"},{"location":"building_the_fw/#configure-the-linux-kernel","text":"Unpack the patch. Then apply it: cd plutosdr-fw/linux/ patch -p1 < /path-to-patch/patch-4.19-rt1.patch Now we will configure the linux kernel. This can be done with menuconfig. First, load the kernel config for the pluto device: cd plutosdr-fw/ make -C linux ARCH=arm zynq_pluto_defconfig Then edit it with menuconfig: make -C linux ARCH=arm menuconfig You will have do make the following changes: Go to: General Setup ---> Preemption Model ---> select Fully Preemptible Kernel (RT) Go to: Device Drivers ---> Network device support ---> Universal TUN/TAP device driver support. Type 'Y' to activate If you cannot find the entries, do a search by typing '/' and go to the search result by typing the result number, e.g. '1'. Go to 'Save' and use arch/arm/configs/zynq_pluto_defconfig to overwrite the default zynq_pluto configuration.","title":"Configure the linux kernel"},{"location":"building_the_fw/#configure-the-userspace-apps","text":"Next, we will activate some useful userspace apps in buildroot. Load the pluto default configuration. make -C buildroot ARCH=arm zynq_pluto_defconfig make -C buildroot ARCH=arm menuconfig Its the easiest to search for the apps with '/', select the result (e.g. '1') and activate it with 'y'. tunctl . Required. Must be installed to configgure the tap device fftw-single . Required. Search term 'single'. We need the single precision fftw library. Make sure to select 'BR2_PACKAGE_FFTW_SINGLE' and not the legacy option. libconfig . Required. Search term 'libconfig'. A library to parse configuration files. lldpd . Required. Link Layer Discovery protocol. Used to broadcast callsigns. iperf3 . Optional but recommended. Useful for bandwidth tests. tcpdump + gdb Optional. Useful for debugging. For me, the External toolchain kernel header version was not correctly configured. If this is not correctly set, building the firmware will fail. I had to set kernel header series 4.10.x, previously it was at 4.9.x. You can do this under 'Toolchain ---> External toolchain kernel headers series'. In order to preinstall our own applications, we will create a rootfs overlay folder and tell buildroot to overlay this folder over the created filesystem. Activate this with: System configuration ---> Root filesystem overlay directories I choose /home/lukas/plutosdr-fw/rootfs-overlay/ , keep in mind the chosen directory name when creating the overlay in the next steps. Save the configuration by using the default path. Then overwrite the pluto target config with the following command: make -C buildroot savedefconfig Now we will fill the rootfs-overlay directory. The git repository containing this readme comes with a script config-firmware.sh . It should do everything on its own. Before you run it, edit it and check that the Variables PLUTOSDR_FW_ROOTOVERLAY and PLUTO_SYSROOT_DIR point to the correct paths. Also, verify that transceiver/CmakeArmToolchain.cmake uses the correct sysroot path and the correct Xilinx toolchain path. Then run: ./config-firmware.sh The script will build all dependent libraries (libfec, liquid-dsp) and the C applications. Then it fills the rootoverlay with the applications, some startup scripts and FIR filter coefficients that we use.","title":"Configure the userspace apps"},{"location":"building_the_fw/#build-firmware-image","text":"Now everything is set up to build the firmware image: cd plutosdr-fw/ make That's it. If you get an error like Incorrect selection of kernel headers: expected 4.14.x, got 4.10.x Incorrect selection of gcc version: expected 8.x, got 7.2.1 You have to clean your current buildroot configuration and have to start from scratch with the last saved config. Go back to the buildroot userspace configuration and make sure to save the configuration at the end. In the menuconfig step check your old settings from above and: Go to: Toolchain -> External Toolchain kernel headers series 4.10.x Go to: Toolchain -> External Toolchain gcc version -> 7.x cd plutosdr-fw/ make -C buildroot ARCH=arm clean make -C buildroot ARCH=arm zynq_pluto_defconfig make -C buildroot ARCH=arm menuconfig make -C buildroot savedefconfig make After the build finished, the firmware image can be found in plutosdr-fw/build/pluto.frm . It can be installed using these instructions .","title":"Build firmware image"},{"location":"installation/","text":"In order to install the system, you just have to flash a precompiled firmware. Get the firmware \u00b6 Download the HNAP4PlutoSDR firmware from here . Install the firmware \u00b6 Connect one Adalm Pluto to your PC and copy the image to the Pluto's mass storage device. Eject the Pluto and wait until the flashing process is completed (LED1 stops blinking). Initial system configuration \u00b6 Now, connect to the Pluto via SSH to initially configure the system. This will set some variables in the permanent memory of the Pluto, so you only have to do this once. The variables will even persist if you flash the firmware again. CPU Setup \u00b6 At first, we have to activate the second core of the ARM CPU. We also isolate core #1 so that no applications will be executed there. The core is dedicated for buffer transfers and some signal processing in our application: fw_setenv maxcpus 2 isolcpus=1 IP Address \u00b6 Next, specify which IP address this Pluto will use within the HNAP Network. You can define any IP address as long as the IP addresses you assign to other Plutos are within one subnet: fw_setenv hnap_tap_ip 192.168.123.1 Connect multiple Plutos to a single computer If you you want to connect both Plutos to the same Host PC for testing, make sure that they use different IP addresses on the Ethernet via USB interface. See here for more info. We suggest that you configure your first Pluto with the IP addresses 192.168.2.1 (pluto) 192.168.2.10 (host PC) and the second with IP address 192.168. 3 .1 (pluto) and 192.168. 3 .10 (host PC) Callsign \u00b6 Set this station's callsign. It will be broadcasted via LLDP: fw_setenv hnap_callsign <YOUR-CALLSIGN> Client or Basestation? \u00b6 If this Pluto will act as a basestation, set this variable to enable autostart of the basestation. If it is going to be a client, just skip this. fw_setenv hnap_bs_autostart 1 That's it. Now reboot the Adalm Pluto. Then do the same steps for your second Pluto. Now you are ready to run a first test of the system!","title":"Installation"},{"location":"installation/#get-the-firmware","text":"Download the HNAP4PlutoSDR firmware from here .","title":"Get the firmware"},{"location":"installation/#install-the-firmware","text":"Connect one Adalm Pluto to your PC and copy the image to the Pluto's mass storage device. Eject the Pluto and wait until the flashing process is completed (LED1 stops blinking).","title":"Install the firmware"},{"location":"installation/#initial-system-configuration","text":"Now, connect to the Pluto via SSH to initially configure the system. This will set some variables in the permanent memory of the Pluto, so you only have to do this once. The variables will even persist if you flash the firmware again.","title":"Initial system configuration"},{"location":"installation/#cpu-setup","text":"At first, we have to activate the second core of the ARM CPU. We also isolate core #1 so that no applications will be executed there. The core is dedicated for buffer transfers and some signal processing in our application: fw_setenv maxcpus 2 isolcpus=1","title":"CPU Setup"},{"location":"installation/#ip-address","text":"Next, specify which IP address this Pluto will use within the HNAP Network. You can define any IP address as long as the IP addresses you assign to other Plutos are within one subnet: fw_setenv hnap_tap_ip 192.168.123.1 Connect multiple Plutos to a single computer If you you want to connect both Plutos to the same Host PC for testing, make sure that they use different IP addresses on the Ethernet via USB interface. See here for more info. We suggest that you configure your first Pluto with the IP addresses 192.168.2.1 (pluto) 192.168.2.10 (host PC) and the second with IP address 192.168. 3 .1 (pluto) and 192.168. 3 .10 (host PC)","title":"IP Address"},{"location":"installation/#callsign","text":"Set this station's callsign. It will be broadcasted via LLDP: fw_setenv hnap_callsign <YOUR-CALLSIGN>","title":"Callsign"},{"location":"installation/#client-or-basestation","text":"If this Pluto will act as a basestation, set this variable to enable autostart of the basestation. If it is going to be a client, just skip this. fw_setenv hnap_bs_autostart 1 That's it. Now reboot the Adalm Pluto. Then do the same steps for your second Pluto. Now you are ready to run a first test of the system!","title":"Client or Basestation?"},{"location":"prerequisites/","text":"In order to run a HNAP system you will need: At least 2 Adalm Plutos UHF antennas. Do not use the original 2.4GHz antennas that ship with the Pluto, they do not work. A TCXO with better accuracy than the original (25ppm). We strongly suggest that you switch the original TCXO, no stable operation can be guaranteed with it. Antenna selection \u00b6 The Pluto does not come with any analog filters after/before the mixing stage. We therefore produce strong intermodulation products (e.g. output with -10dBc @1.31GHz). These products will be mixed down to the baseband at the receiver and interfere with our signal. Use UHF antennas in order to suppress the intermodulation products. DO NOT use the original 2.4GHz antennas! They just recept the intermodulation products, but not the original signal at 440MHz. TCXO modification \u00b6 The original TCXO in the Adalm Pluto has an accuracy of 25ppm. At 440MHz carrier frequency, this could result in frequency offsets of up to 10kHz. Only up to +-2kHz can be detected by our system. Additionally, the frequency drifts over time introduced by temperature changes can be too severe to be compensated. We therefore strongly suggest to switch to a more accurate TCXO. We switched to a 0.5ppm TCXO. Amplifier selection \u00b6 If you run the system for the first time, its best to start without any amplifier. If you want to try one out, here are some basic requirements: The system is OFDM based, so a linear amplifier is required. The clients in the system operate in half-duplex mode, with a short guard time between the slots for switching the amplifier. The maximum allowed TX-RX switch time of the amplifier is 265us. Currently a PTT signal is generated at the MIO0 Pin of the Adalm Pluto which can be used to drive the amplifier. The pin has a voltage level of 1.8V. We could not yet perform tests including amplifiers, we will update as soon as we have first results.","title":"Prerequisites"},{"location":"prerequisites/#antenna-selection","text":"The Pluto does not come with any analog filters after/before the mixing stage. We therefore produce strong intermodulation products (e.g. output with -10dBc @1.31GHz). These products will be mixed down to the baseband at the receiver and interfere with our signal. Use UHF antennas in order to suppress the intermodulation products. DO NOT use the original 2.4GHz antennas! They just recept the intermodulation products, but not the original signal at 440MHz.","title":"Antenna selection"},{"location":"prerequisites/#tcxo-modification","text":"The original TCXO in the Adalm Pluto has an accuracy of 25ppm. At 440MHz carrier frequency, this could result in frequency offsets of up to 10kHz. Only up to +-2kHz can be detected by our system. Additionally, the frequency drifts over time introduced by temperature changes can be too severe to be compensated. We therefore strongly suggest to switch to a more accurate TCXO. We switched to a 0.5ppm TCXO.","title":"TCXO modification"},{"location":"prerequisites/#amplifier-selection","text":"If you run the system for the first time, its best to start without any amplifier. If you want to try one out, here are some basic requirements: The system is OFDM based, so a linear amplifier is required. The clients in the system operate in half-duplex mode, with a short guard time between the slots for switching the amplifier. The maximum allowed TX-RX switch time of the amplifier is 265us. Currently a PTT signal is generated at the MIO0 Pin of the Adalm Pluto which can be used to drive the amplifier. The pin has a voltage level of 1.8V. We could not yet perform tests including amplifiers, we will update as soon as we have first results.","title":"Amplifier selection"},{"location":"system_config/","text":"Here is how to use the Client and Basestation application. All applications are located in /root/ directory. ./client -g RXGAIN -t TXGAIN -f FREQ -u ULMCS -d DLMCS -c CONFIG-FILE -l LOGLEVEL ./basestation -g RXGAIN -t TXGAIN -f FREQ -c CONFIG-FILE -l LOGLEVEL Client Arguments \u00b6 Modulation and Coding scheme \u00b6 The system uses QAM modulation and convolutional coding at the PHY layer. By default, MCS 0 (QPSK, 1/2 rate code) is used. You can manually set other MCS values for uplink and downlink as an argument to the client application. Downlink MCS can be set with the -d or --dl-mcs flag. Uplink MCS can be set with the -u or --ul-mcs flag. The following MCS have been defined MCS value modulation conv-coding Notes 0 QPSK k=7, r=1/2 ~80kbps 1 QPSK k=7, r=3/4 ~120kbps 2 QAM16 k=7, r=1/2 ~180kbps 3 QAM16 k=7, r=3/4 ~280kbps 4 QAM64 k=7, r=1/2 ~280kbps 5 QAM64 k=7, r=3/4 currently unstable. sometimes not working 6 QAM256 k=7, r=1/2 ~380kbps Gain \u00b6 By default the RXGAIN is automatically set during startup-phase and adapted during runtime of the client. If you want to manually fix the gain, use the -g flag. The gain can be set in the range of [0...73]. The application client-calib can be used to read the current signal level of the application. It prints the absolute amplitudes of the I and Q path and the calculated rssi. RXGAIN should be set to keep the RSSI at ~-15dB. ./client-calib -g <rxgain> The TXGAIN of the client is automatically set, assuming a symmetrical UL and DL link. It is calculated from RX and TX gain broadcasts that the basestation sends and the RXGAIN that the client calculated: txgain_client = bs_txgain + rxgain_client - bs_rxgain In the current implementation, neither the RXGAIN of the basestation nor the TXGAIN of a client are adaptive. This feature still has to be implemented. Carrier frequency \u00b6 You can specify the carrier frequency of the downlink channel with the -f parameter. The frequency is given in Hz. The uplink frequency is automatically calculated (4.8 MHz shift). Log level \u00b6 Define the log level of the application with the -l parameter. 0=TRACE 1=DEBUG 2=INFO 3=WARN 4=ERR 5=NONE Configuration file \u00b6 The OFDM system can be customized. You can define your own pilot allocation scheme, redefine the number of data subcarriers and much more. See advanced config for more information.","title":"Configuration"},{"location":"system_config/#client-arguments","text":"","title":"Client Arguments"},{"location":"system_config/#modulation-and-coding-scheme","text":"The system uses QAM modulation and convolutional coding at the PHY layer. By default, MCS 0 (QPSK, 1/2 rate code) is used. You can manually set other MCS values for uplink and downlink as an argument to the client application. Downlink MCS can be set with the -d or --dl-mcs flag. Uplink MCS can be set with the -u or --ul-mcs flag. The following MCS have been defined MCS value modulation conv-coding Notes 0 QPSK k=7, r=1/2 ~80kbps 1 QPSK k=7, r=3/4 ~120kbps 2 QAM16 k=7, r=1/2 ~180kbps 3 QAM16 k=7, r=3/4 ~280kbps 4 QAM64 k=7, r=1/2 ~280kbps 5 QAM64 k=7, r=3/4 currently unstable. sometimes not working 6 QAM256 k=7, r=1/2 ~380kbps","title":"Modulation and Coding scheme"},{"location":"system_config/#gain","text":"By default the RXGAIN is automatically set during startup-phase and adapted during runtime of the client. If you want to manually fix the gain, use the -g flag. The gain can be set in the range of [0...73]. The application client-calib can be used to read the current signal level of the application. It prints the absolute amplitudes of the I and Q path and the calculated rssi. RXGAIN should be set to keep the RSSI at ~-15dB. ./client-calib -g <rxgain> The TXGAIN of the client is automatically set, assuming a symmetrical UL and DL link. It is calculated from RX and TX gain broadcasts that the basestation sends and the RXGAIN that the client calculated: txgain_client = bs_txgain + rxgain_client - bs_rxgain In the current implementation, neither the RXGAIN of the basestation nor the TXGAIN of a client are adaptive. This feature still has to be implemented.","title":"Gain"},{"location":"system_config/#carrier-frequency","text":"You can specify the carrier frequency of the downlink channel with the -f parameter. The frequency is given in Hz. The uplink frequency is automatically calculated (4.8 MHz shift).","title":"Carrier frequency"},{"location":"system_config/#log-level","text":"Define the log level of the application with the -l parameter. 0=TRACE 1=DEBUG 2=INFO 3=WARN 4=ERR 5=NONE","title":"Log level"},{"location":"system_config/#configuration-file","text":"The OFDM system can be customized. You can define your own pilot allocation scheme, redefine the number of data subcarriers and much more. See advanced config for more information.","title":"Configuration file"},{"location":"usage/","text":"Once you have installed the application and performed the initial system configuration, you can test the system. Your basestation should start automatically once it is connected to power. In order to start you client log into the system via SSH and do: ./client The client should start up and connect to the basestation. Once this is done, open another SSH connection and test the HNAP connection with ping or iperf . Every Pluto starts an iperf3 server by default, so simply run: iperf3 -c 192.168.123.1 -R Troubleshooting \u00b6 If the client is not able to connect to the basestation, the following might help: Make sure the second CPU core is active Verify it with fw_printenv maxcpus and set up according to here . Without the second core, no realtime operation is possible. Use correct antennas for the used band The Pluto does not come with any analog filters after/before the mixing stage. We therefore produce strong intermodulation products (e.g. output with -10dBc @1.31GHz). These products will be mixed down to the baseband at the receiver and interfere with our signal. Use UHF antennas in order to suppress the intermodulation products. DO NOT use the original 2.4GHz antennas! They just recept the intermodulation products, but not the original signal at 440MHz. Adjust the carrier frequency The default TCXO on the Adalm Pluto has an accuracy of 25ppm. At 440MHz, this can result in a frequency offset of up to 10kHz. The application can only detect and compensate +-2kHz, we therefore strongly suggest to switch to a more accurate TCXO (more details here TODO!). If you do not want to swap the TCXO immediately, try the following: 1. Let the Pluto heat up a bit. The frequency drift is very high in the first minutes of operation. Wait some minutes for the offset to settle. 2. Adjust the frequency offset manually. Run ./client -f 439702000 to tune to higher and lower carrier frequencies. Do this in 2kHz steps around the default frequency of 439700000. There is a calibration tool client-calib that only syncs to the Downlink and estimates the carrier offset that might help: ./client-calib -f <DL-FREQ> What's next? \u00b6 Get higher data-rates by changing the modulation coding scheme: here Read how to build the firmware yourself here","title":"Usage"},{"location":"usage/#troubleshooting","text":"If the client is not able to connect to the basestation, the following might help: Make sure the second CPU core is active Verify it with fw_printenv maxcpus and set up according to here . Without the second core, no realtime operation is possible. Use correct antennas for the used band The Pluto does not come with any analog filters after/before the mixing stage. We therefore produce strong intermodulation products (e.g. output with -10dBc @1.31GHz). These products will be mixed down to the baseband at the receiver and interfere with our signal. Use UHF antennas in order to suppress the intermodulation products. DO NOT use the original 2.4GHz antennas! They just recept the intermodulation products, but not the original signal at 440MHz. Adjust the carrier frequency The default TCXO on the Adalm Pluto has an accuracy of 25ppm. At 440MHz, this can result in a frequency offset of up to 10kHz. The application can only detect and compensate +-2kHz, we therefore strongly suggest to switch to a more accurate TCXO (more details here TODO!). If you do not want to swap the TCXO immediately, try the following: 1. Let the Pluto heat up a bit. The frequency drift is very high in the first minutes of operation. Wait some minutes for the offset to settle. 2. Adjust the frequency offset manually. Run ./client -f 439702000 to tune to higher and lower carrier frequencies. Do this in 2kHz steps around the default frequency of 439700000. There is a calibration tool client-calib that only syncs to the Downlink and estimates the carrier offset that might help: ./client-calib -f <DL-FREQ>","title":"Troubleshooting"},{"location":"usage/#whats-next","text":"Get higher data-rates by changing the modulation coding scheme: here Read how to build the firmware yourself here","title":"What's next?"},{"location":"documentation/callsign/","text":"Callsign broadcasting \u00b6 All amateur radio stations are required to transmit their callsign regulary. We comply with this requirement by using the Link Layer Discovery Protocol (LLDP). Every Adalm Pluto hosts a lldp daemon that is configured to broadcast a LLDP packet every 60 seconds. This packet contains the Callsign of the station. The configuration takes place in /etc/init.d/S90transceiver.sh . We evaluate the variable hnap_callsign , which can be set via the command: fw_setenv hnap_callsign <YOUR-CALLSIGN> You can view the current LLDP configuration with lldpcli show config . All received LLDP information from other stations can be displayer with lldpcli show neigh . For more info, view the lldpd and lldpdcli manual","title":"Callsign Distribution"},{"location":"documentation/callsign/#callsign-broadcasting","text":"All amateur radio stations are required to transmit their callsign regulary. We comply with this requirement by using the Link Layer Discovery Protocol (LLDP). Every Adalm Pluto hosts a lldp daemon that is configured to broadcast a LLDP packet every 60 seconds. This packet contains the Callsign of the station. The configuration takes place in /etc/init.d/S90transceiver.sh . We evaluate the variable hnap_callsign , which can be set via the command: fw_setenv hnap_callsign <YOUR-CALLSIGN> You can view the current LLDP configuration with lldpcli show config . All received LLDP information from other stations can be displayer with lldpcli show neigh . For more info, view the lldpd and lldpdcli manual","title":"Callsign broadcasting"}]}